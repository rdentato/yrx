def @tag { {Symbol Base} @Font t }
def @ttt { {Italic} @Font to }
@SysInclude { tbl }
@SysInclude { diag }
@SysInclude { math }
@SysInclude { pas }
@SysInclude { report }
@Report
@Title {YRX - A regular expression package for C}
@Author {Remo Dentato}
@Institution {rdentato@users.sourceforge.net}
@DateLine {Yes }
@AtEnd {}
@CoverSheet { No }
@ContentsSeparate { No }
@InitialFont { Times Base 12p }
@InitialBreak { hyphen adjust 1.2fx }
@InitialSpace { lout }
@InitialLanguage { English }
@PageOrientation { Portrait }
@PageHeaders { Simple }
@ColumnNumber { 1 }
@FirstPageNumber { 1 }
@OptimizePages { No }
@AbstractDisplay { No }
@AbstractTitle { Abstract }
@Abstract {}
@GlossaryText { @Null }
@IndexText { @Null }
@IndexAText { @Null }
@IndexBText { @Null }
//

@Section
@Title { Introduction }
@Begin
@PP
YRX is a package to create lexical scanners. At its core
there is a function that takes a set of regular expressions
and transform it in a Determinstic Finite Automata which is
then transformed in code or simulated.

@LP
YRX makes use of @I{tagged automata} where each arc may carry
a set of @I{tags}. The idea of using tags for marking the current
position within the input text was initially found in @Cite {$AhoUllman77}
where Aho and Ullman suggest to use an {@Sym epsilon}-transition tagged
with @F "/" to implement the lookahed operator.

@LP
Ville Laurikari in @Cite{$Laurikari} fully described how to solve the
submatch problem using tagged automata. I believe that YRX automata are a
subset of Laurikari's ones but I have made no attempt to prove it.

@LP
The substring matching problem was also solved in @Cite {$dube00} where
Dube and Feeley describe an approach based on building the parse tree of
a regular expression.

@End @Section

@Section
@Title { Regular Expressions }
@Begin

@PP YRX regular expressions are defined as follows:

@DP {0.9f @Font @Tbl 
aformat {@Cell A | @Cell B}
{
@Rowa A {}   B{Any non-special character matches itself}
@Rowa A {.}  B{matches any character}
@Rowa A {()} B{delimit captures}
@Rowa A {"\\"} B{escape next character. If there's no special
meaning associated with the escaped sequence,
the regular character is matched.}
@Rowa A {[]} B{delimit character class}
@Rowa A {*} B{Matches preceding expression zero or more times.}
@Rowa A {+} B{As above but matches one or more repetitions.}
@Rowa A {?} B{As above but matches only zero or one repetitions.}
@Rowa A {"\\!"} B{Mark right context} 
@Rowa A {"\\"@I{ooo}} B{matches the character whose code is @I{ooo} in octal}  
@Rowa A {"\\a"} B{Equivalent to [A-Za-z]} 
@Rowa A {"\\A"} B{Equivalent to "[\^A-Za-z]"}
@Rowa A {"\\b"} B{Matches a backspace character (ASCII 8)}
@Rowa A {"\\d"} B{Equivalent to [0-9]}
@Rowa A {"\\D"} B{Equivalent to "[\^0-9]"}
@Rowa A {"\\e"} B{An escaped character (see section xx)}
@Rowa A {"\\E"} B{Change the escape character (see section xx)}
@Rowa A {"\\f"} B{Matches a form feed (ASCII x)}
@Rowa A {"\\h"} B{Equivalent to [0-9A-Z-z]}
@Rowa A {"\\H"} B{Equivalent to "[\^0-9A-Z-z]"}
@Rowa A {"\\l"} B{Equivalent to [a-z]} 
@Rowa A {"\\L"} B{Equivalent to "[\^a-z]"}
@Rowa A {"\\n"} B{Matches a newline (ASCII 10)}
@Rowa A {"\\o"} B{Equivalent to [0-7]} 
@Rowa A {"\\O"} B{Equivalent to "[\^0-7]"}
@Rowa A {"\\r"} B{Matches a carraige return (ASCII 13)}
@Rowa A {"\\s"} B{Equivalent to [" \\n\\r\\b\\t\\v\\f"]} 
@Rowa A {"\\S"} B{Equivalent to ["\^ \\n\\r\\b\\t\\v\\f"]} 
@Rowa A {"\\t"} B{Matches a tab (ASCII 9)}
@Rowa A {"\\u"} B{Equivalent to [A-Z]} 
@Rowa A {"\\U"} B{Equivalent to "[\^A-Z]"}
@Rowa A {"\\v"} B{Matches a vertical tab (ASCII x)}
@Rowa A {"\\x"@I{hh}} B{matches the character whose code is @I{hh} in hexadecimal}
@Rowa A {"\\w"} B{Equivalent to [_"\\a"]} 
@Rowa A {"\\W"} B{Equivalent to ["\^\\w]"}
@Rowa A {"\\y"} B{Equivalent to [" \\t"]} 
@Rowa A {"\\Y"} B{Equivalent to ["\^ \\t"]} 
}
}
## @DP

@End @Section

@Section
@Title { Tagged automata }
@Begin

@PP
Each tag @M{ @tag supp d on x } assigns to an associated variable
@M{v sub x} the value @M{pos - d} where @M{pos} is the current position
within the input text.

@LP
Given a tag @M{s = @tag supp d on x } , @I {x} is said to be the @I type
of @I{s} and @I{d} the @I displacement of @I{s}.

@LP
The tag @I increment operation @M{()sup{+}} is defined such that:
  @M{({@tag supp d on {x}}) sup {+} =  {@tag supp {(d+1)} on x} }
  
@LP
The increment operation over a set of tags
@M{S = {lbrace s sub 1, s sub 2 ,..., s sub n rbrace }} 
is defined such that:
@DP @Center 
  @Math {(S) sup{+} 
              = lbrace (s sub {1}) sup {+}, (s sub {2}) sup {+} ,..., (s sub {n}) sup {+} rbrace }

@DP
##   Given a set of tags @M{S = {lbrace s sub 1, s sub 2 ,..., s sub n rbrace }}
## and a tag @M{@tag supp d on x}, @I adding a tag to @M {S} is defined as:
## 
## @DP @Center @Math {
##   S circleplus @tag supp d on {x} = 
##       matrix atleft { blbrace  }  {
##         row col {{lbrace s sub 1, s sub 2 ,..., s sub n, @tag supp d on {x} rbrace } /0.3c
##         {lbrace s sub 1 ,..., s sub {j-1} , @tag supp {min(k,d)} on x , s sub {j+1} ,..., s sub n rbrace }}
##             col {{@R if " " not exists " " j @R" : " s sub j = @tag supp k on x in S } /0.3c
##                 {@R if " "  exists " " j @R" : " s sub j = @tag supp k on x in S }}
##       }
## }
## @DP
## 
The @I addition operation between tags is defined such that:
@DP
@Center @Math {
  @tag supp k on {y} circleplus @tag supp d on {w} = 
      matrix atleft { blbrace  }  {
        row col {{lbrace  @tag supp k on {y} , @tag supp d on {w}  rbrace } /0.3c
                 {lbrace @tag supp {min(k,d)} on {y} rbrace}
                }
            col {{@R if " " y != w} /0.3c
                 {@R if " " y = w}
                }
      }
}

@DP
Informally, the @I addition of two tags is a set which contains both tags
if they are of different types or a tag of the same type with a
displacement that is the minimum of the two displacements.

@LP

Given two sets of tags @M{S = {lbrace s sub 1, s sub 2 ,..., s sub n rbrace }},
and @M{R = {lbrace r sub 1, r sub 2 ,..., r sub m rbrace }} 
the following operations are defined:

@DP @Center
@Math {
  matrix  {
    row mcol {S cup tsub @tag " " R 
              ^= big bcup atop {0.7f @Font {{1 <= i <= n} /0.1c {1 <= j <= m}} } (s sub i circleplus r sub j ) }
        lcol {"   "} lcol {@R{"tag-union"}}
    row lcol {" "}             
              
    row mcol { S " " minus " " R
              ^=  {lbrace @tag supp d on x " | " @tag supp d on x in S "  " logicaland "  " @tag supp d on x notin R rbrace } }
        lcol {"   "} lcol {@R{"difference"}}
    row lcol {" "}             
    row mcol { S " " cap " " R 
              ^= {lbrace  @tag supp {d} on x " | " @tag supp d on x in S "  " logicaland "  " @tag supp d on x in R  rbrace }}
        lcol {"   "} lcol {@R{"intersection"}}
  }
}

@DP
Note that only the union had to be redefined to take tags into account,
the other oprations are the standard ones. 

## Given the above definitions it's easy to check that the usual property
## @M{S minus R = S minus (S cap R)} holds.

@LP 
Two regular expressions @M{r} and @M{s}, are @I equivalent (@M{r = s})
if they accept the same language.

@LP
Two regular expressions @M{r} and @M{s}, are @I {tag-equivalent}
(@M{r = tsub @tag " " s}) if they are equivalent and specify the same
sets of tags.

@LP
For example @M{ a(bc)d = (ab)cd} as they both accept the
language containing the only string @F {abcd}, but  
@M{ a(bc)d  notequal sub @tag " " (ab)cd} as the tags variables
will have different values upon successful match.

@LP
In the following we'll refer to four types of tags:

@CD 0.9 @Scale @Tbl
aformat{ @Cell width {8f} A| @Cell  width {5f} i {ctr} B | @Cell  width {3f} C }
{
@Rowa
A { Tag }
B { Symbol }
C { Var}
#D { @M{sel()} }
rulebelow { yes }
@Rowa
A { Begin Capture }
B { @M{( supp d on n} }
C { @M{bc sub n } }
#D { @M{max(x,y) } }
@Rowa
A { End Capture }
B { @M{) supp d on n} }
C { @M{ec sub n } }
#D { @M{min(x,y) }}
@Rowa
A { Mark }
B { @M{"#" sup d} }
C { @M{mrk} }
#D { @M{min(x,y) }}
@Rowa
A { Match }
B { @M{$ sup d} }
C { @M{end} }
#D { @M{min(x,y) }}
}

@LP
 The interpretation of
a tagged transition labeled with @M{ @F{a} " / " @tag supp d on x}
is that upon reading the character @F{a}, the
value of the @M{v sub x} is set to current position 
minus @M{d} and the FA moves from a state to the other.

@LP
No interpretation is given for {@Sym epsilon}-transitions
as their only purpose will be to help propagating tags.

## @Diag{
##  { A:: @Circle hsize {0.45f} {0.7f @Font {1}}} |1.5c 
##  { B:: @Circle hsize {0.45f} {0.7f @Font {2}}}
##  //
##  @Arrow from {A} to {B} ylabel { @M{epsilon " / " @tag supp d on x}} 
## }
 
@End @Section

@Section
@Title { From RE to TNFA }
@Begin
@PP
The diagrams in figure @NumberOf{re2nfa} shows how to convert a regular
expression into a TNFA. 


@Figure
@Caption { Construction of NFA }
@Tag { re2nfa }
0.9 @Scale {
{
@LP
@Diag {
@Tbl
aformat { @Cell A | @Cell i {ctr} B | @Cell C }
marginhorizontal { 0.3c }
marginvertical { 0.2c }
{
@Rowa
A { A:: @Circle hsize {0.5f} {0.75f @Font {1}}}
C { B:: @Circle hsize {0.5f} {0.75f @Font {2}}}
@Rowa
B { a }
}
//
@Arrow from { A } to { B } ylabel { 1.2f @Font {@I a}}
}

@Diag {
@Tbl
aformat { @Cell A | @Cell B | @Cell C }
marginhorizontal { 0.3c }
marginvertical { 0.2c }
{
@Rowa
A { A:: @Circle hsize {0.5f} {0.75f @Font {1}}}
C { B:: @Circle hsize {0.5f} {0.75f @Font {2}}}
@Rowa
B { a* }
}
//
@Arrow from { A } to { B } ylabel { 1.2f @Font {@Sym epsilon}}
@CurveArrow arrowstyle { solid } bias {1c} from { A@NE } to { A@NW }
            ylabel { 1.2f @Font {@I a}}
}

@Diag {
@Tbl
aformat { @Cell A | @Cell B | @Cell C }
marginhorizontal { 0.3c }
marginvertical { 0.2c }
{
@Rowa
A { A:: @Circle hsize {0.5f} {0.75f @Font {1}}}
C { B:: @Circle hsize {0.5f} {0.75f @Font {2}}}
@Rowa
B { a+ }
}
//
@Arrow from { A } to { B } ylabel { 1.2f @Font {@I a}}
@CurveArrow arrowstyle { solid } bias {1c} from { B@E }
            to { B@N } ylabel { 1.2f @Font {@I a}}
}

@LP @LP

@Diag {
@Tbl
aformat { @Cell A | @Cell i {ctr} B | @Cell C }
marginhorizontal { 0.3c }
marginvertical { 0.2c }
{
@Rowa
A { A:: @Circle hsize {0.5f} {0.75f @Font {1}}}
C { B:: @Circle hsize {0.5f} {0.75f @Font {2}}}
@Rowa
B { a? }
}
//
@Arrow from { A } to { B } ylabel { 1.2f @Font {@I a}}
@CCurveArrow bias {0.5c} from { A } to { B } ylabel { 1.2f @Font {@I @Sym epsilon}}
}

@Diag {
@Tbl
aformat { @Cell A | @Cell B | @Cell C | @Cell D | @Cell E }
marginhorizontal { 0.25c }
marginvertical { 0.2c }
{
@Rowa
A { A:: @Circle hsize {0.5f} {0.75f @Font {1}}}
C { B:: @Circle hsize {0.5f} {0.75f @Font {2}}}
E { C:: @Circle hsize {0.5f} {0.75f @Font {3}}}
@Rowa
C { @Center {ab} }
}
//
@Arrow from { A } to { B } ylabel { 1.2f @Font {@I a}}
@Arrow from { B } to { C } ylabel { 1.2f @Font {@I b}}
}
@Diag {
@Tbl
aformat { @Cell A | @Cell i {ctr} B | @Cell C }
marginhorizontal { 0.3c }
marginvertical { 0.2c }
{
@Rowa
A { A:: @Circle hsize {0.5f} {0.75f @Font {1}}}
C { B:: @Circle hsize {0.5f} {0.75f @Font {2}}}
@Rowa
B { [ab] }
}

//
@Arrow from { A } to { B } ylabel { 1.2f @Font {@I [ab]}}
}

@LP @LP

@Diag {
@Tbl
aformat { @Cell A | @Cell B | @Cell C | @Cell D | @Cell i {ctr} E | @Cell F | @Cell G | @Cell H | @Cell I | @Cell iv{ctr} i{ctr} J }
marginhorizontal { 0.3c }
marginvertical { 0.2c }
{
@Rowa
A { A:: @Circle hsize {0.5f} {0.75f @Font {1}}}
C { B:: @Circle hsize {0.5f} {0.75f @Font {2}}}
E { C:: @Circle hsize {0.5f} {0.75f @Font {5}}}
G { D:: @Circle hsize {0.5f} {0.75f @Font {3}}}
I { E:: @Circle hsize {0.5f} {0.75f @Font {4}}}
J { (X) }
@Rowa
A { }
}
//
@Arrow from { A } to { B } ylabel { 1.2f @Font {@Sym epsilon "/\(" }}
@Arrow from { B } to { C } ylabel { 1.2f @Font {@I X}} pathstyle { dashed } pathwidth {thick}
@Arrow from { C } to { D } ylabel { 1.2f @Font {@Sym epsilon }}
@Arrow from { D } to { E } ylabel { 1.2f @Font {@Sym epsilon "/\)" }}
}

@LP @LP

@Diag {
@Tbl
aformat { @Cell A | @Cell B | @Cell C | @Cell D | @Cell i {ctr} E | @Cell F | @Cell G | @Cell H | @Cell I  | @Cell iv{ctr} i{ctr} J }
marginhorizontal { 0.3c }
marginvertical { 0.2c }
{
@Rowa
A { A:: @Circle hsize {0.5f} {0.75f @Font {1}}}
C { B:: @Circle hsize {0.5f} {0.75f @Font {2}}}
E { C:: @Circle hsize {0.5f} {0.75f @Font {5}}}
G { D:: @Circle hsize {0.5f} {0.75f @Font {3}}}
I { E:: @Circle hsize {0.5f} {0.75f @Font {4}}}
J { (X)? }
@Rowa
E { }
}
//
@Arrow from { A } to { B } ylabel { 1.2f @Font {@Sym epsilon "/\(" }}
@Arrow from { B } to { C } ylabel { 1.2f @Font {@I X}} pathstyle { dashed } pathwidth {thick}
@Arrow from { C } to { D } ylabel { 1.2f @Font {@Sym epsilon }}
@CCurveArrow bias {1.2c} from { B } to { E } ylabel { 1.2f @Font {@Sym epsilon "/\)" }}
@Arrow from { D } to { E } ylabel { 1.2f @Font {@Sym epsilon "/\)" }}
}
@LP

@Diag {
@Tbl
aformat { @Cell A | @Cell B | @Cell C | @Cell D | @Cell i {ctr} E | @Cell F | @Cell G | @Cell H | @Cell I  | @Cell iv{ctr} i{ctr} J }
marginhorizontal { 0.3c }
marginvertical { 0.3c }
{
@Rowa
A { A:: @Circle hsize {0.5f} {0.75f @Font {1}}}
C { B:: @Circle hsize {0.5f} {0.75f @Font {2}}}
E { C:: @Circle hsize {0.5f} {0.75f @Font {5}}}
G { D:: @Circle hsize {0.5f} {0.75f @Font {3}}}
I { E:: @Circle hsize {0.5f} {0.75f @Font {4}}}
J { (X)+ }
@Rowa
E { }
}
//
@Arrow from { A } to { B } ylabel { 1.2f @Font {@Sym epsilon "/\(" }}
@Arrow from { B } to { C } ylabel { 1.2f @Font {@I X}} pathstyle { dashed } pathwidth {thick}
@Arrow from { C } to { D } ylabel { 1.2f @Font {@Sym epsilon }}
@CCurveArrow from { D } to { B } ylabel { 1.2f @Font {@Sym epsilon }}
@Arrow from { D } to { E } ylabel { 1.2f @Font {@Sym epsilon "/\)" }}
}

@LP @LP

@Diag {
@Tbl
aformat { @Cell A | @Cell B | @Cell C | @Cell D | @Cell i {ctr} E | @Cell F | @Cell G | @Cell H | @Cell I  | @Cell iv{ctr} i{ctr} J }
marginhorizontal { 0.3c }
marginvertical { 0.3c }
{
@Rowa
A { A:: @Circle hsize {0.5f} {0.75f @Font {1}}}
C { B:: @Circle hsize {0.5f} {0.75f @Font {2}}}
E { C:: @Circle hsize {0.5f} {0.75f @Font {5}}}
G { D:: @Circle hsize {0.5f} {0.75f @Font {3}}}
I { E:: @Circle hsize {0.5f} {0.75f @Font {4}}}
J { (X)* }
@Rowa
E {  }
}
//
# @Arrow from { A } to { B } ylabel { 1.2f @Font {@Sym epsilon "/\(" }}
@Arrow from { B } to { C } ylabel { 1.2f @Font {@I X}} pathstyle { dashed } pathwidth {thick}
@Arrow from { C } to { D } ylabel { 1.2f @Font {@Sym epsilon }}
@CCurveArrow from { D } to { B } ylabel { 1.2f @Font {@Sym epsilon }}
@CCurveArrow bias {1.2c} from { A } to { D } ylabel { 1.2f @Font {@Sym epsilon "/\("}}
@Arrow from { D } to { E } ylabel { 1.2f @Font {@Sym epsilon "/\)" }}
}

@LP

@Diag {
@Tbl
aformat { @Cell iv {ctr} A | @Cell B | @Cell iv {ctr} C | @Cell D | @Cell i {ctr} E | @Cell F | @Cell iv {ctr} G | @Cell H | @Cell iv {ctr} I  | @Cell iv{ctr} i{ctr} J }
marginhorizontal { 0.3c }
marginvertical { 0.25c }
{
@Rowa
A { A:: @Circle hsize {0.5f} {0.75f @Font {1}}}
C { B:: @Circle hsize {0.5f} {0.75f @Font {2}}}
E { C:: @Circle hsize {0.5f} {0.75f @Font {5}} /0.5c F:: @Circle hsize {0.5f} {0.75f @Font {6}} }
G { D:: @Circle hsize {0.5f} {0.75f @Font {3}}}
I { E:: @Circle hsize {0.5f} {0.75f @Font {4}}}
J { (X"|"Y) }
@Rowa
E {  }
}
//
@Arrow from { A } to { B } ylabel { 1.2f @Font {@Sym epsilon "/\(" }}
@CCurveArrow bias {0.25c} from { B } to { C } ylabel { 1.2f @Font {@I X}} pathstyle { dashed } pathwidth {thick}
@CurveArrow  bias {0.25c} from { B } to { F } ylabel { 1.2f @Font {@I Y}} pathstyle { dashed } pathwidth {thick} ylabelprox {below } 
@CCurveArrow bias {0.25c} from { C } to { D } ylabel { 1.2f @Font {@Sym epsilon }}
@CurveArrow  bias {0.25c} from { F } to { D } ylabel { 1.2f @Font {@Sym epsilon }} ylabelprox {below } 
@Arrow from { D } to { E } ylabel { 1.2f @Font {@Sym epsilon "/\)" }}
}
@LP

@Diag {
@Tbl
aformat { @Cell A | @Cell B | @Cell C | @Cell D | @Cell i {ctr} E | @Cell F | @Cell G | @Cell iv{ctr} i{ctr} H }
marginhorizontal { 0.3c }
marginvertical { 0.2c }
{
@Rowa
A { A:: @Circle hsize {0.5f} {0.75f @Font {1}}}
C { B:: @Circle hsize {0.5f} {0.75f @Font {2}}}
E { C:: @Circle hsize {0.5f} {0.75f @Font {3}}}
G { D:: @Circle hsize {0.5f} {0.75f @Font {4}}}
H { "a\\!b" }

}
//
@Arrow from { A } to { B } ylabel { 1.2f @Font a} 
@Arrow from { B } to { C } ylabel { 1.2f @Font {@Sym epsilon "/#" }}
@Arrow from { C } to { D } ylabel { 1.2f @Font b}
}

@Diag {
@Tbl
aformat { @Cell A | @Cell B | @Cell C | @Cell D | @Cell i {ctr} E | @Cell iv{ctr} i{ctr} F }
marginhorizontal { 0.3c }
marginvertical { 0.2c }
{
@Rowa
A { A:: @Circle hsize {0.5f} {0.75f @Font {1}}}
C { B:: @Circle hsize {0.5f} {0.75f @Font {2}}}
E { C:: @Circle paint {lightgrey} hsize {0.5f} {0.75f @Font {0}}}
F { "a" }
}
//
@Arrow from { A } to { B } ylabel { 1.2f @Font a} 
@Arrow from { B } to { C } ylabel { 1.2f @Font {@Sym lambda "/ $" }}
}
}
}

@LP
As the last diagram shows, final states are denoted using transition to 
state 0 under a special character {@Sym lambda} tagged with '$'. This 
implies that at the end of the string to be matched, the value of @M{pos}
is 1 past the position of the last character.

@LP
Introducing tags as described, will generate {@Sym epsilon}-automata
with a fairly high number of states. Most of those states, however, will
become unreachable once the tags will be propagated to arcs that carry
actual labels. Infact we have:

@LD @Theorem
{Given a regular expression @M{r}, the corresponding {@Sym epsilon}-free
NFA has at most @M{bar r bar + 1} states.
@LP
@Proof Yet to be figured out. And also, the theorem does not hold
for @M{(X bar Y)}. If changing @M{a+} will be enough, good otherwise
I'll introduce a term to take it into account.@EndProof
}

Note that in the construction of the terms @M{(X)*}
and @M{(X)+}, due to the way the determinization algorithm works,
the arc that expresses the {@I looping} goes from state 3
to state 2, not reassigning the start value of the term capture.
This means that we forced @M{(a)* " " equal sub @tag " " (a*)} even if
the opposite should have been done.

@LP
For example, in the expression @M{a(b)*c}, given the string @F {abbbc},
the length of the capture will be 3, exactly as if we had 
written  @M{a(b*)c}.

@End @Section

    
@Section
@Title { From NFA to DFA }
@Begin
@PP

## There are two source of non-determinism in a NFA constructed using the
## rules defined in figure @NumberOf{re2nfa} transitions that can be followed
## without consuming any input ({@Sym epsilon}-transitions) and multiple
## transitions under the same character (ambiguous transition).
 
The determinization algorithm processes each state once removing
{@Sym epsilon}-transitions first (possibly introducing new ambiguous
transitions) and then resolving any ambiguities:

@ID @OneRow @Pas {
pushonce( stack, 1 )
while not isempty( stack ) do
    state = pop( stack )
    removeeps( state )
    mergearcs( state )
end
}

The algorithm uses a stack with a modified discipline to ensure that only
reachable states are visited. The function @F{pushonce()} only pushes a
value in the the stack if that value has not already been pushed previously.

@LP
The functions @F{removeeps()} and @F{mergearcs()} will push into the stack
the destination states so that the computation continues.

@LD @Theorem
{
The algorithm x is equivalent to the classical subset construction
algorithm.
@LP
@Proof To be figured out.@EndProof
}

@BeginSubSections

@SubSection
@Title { Elimination of {@Sym epsilon}-transitions }
@Begin
@PP
The key idea is that an {@Sym epsilon}-transition from a state @I x to a state
@I y implies that all states reachable from @I y are also reachable from @I x.
In other words the {@Sym epsilon}-transition from @I x to @I y can be removed
and replaced with the set of arcs @I x to the states to the states reachable
from @I y.

@LP
Figure @NumberOf{removeeps} shows how labels and tags are propagated during
{@Sym epsilon}-transitions removal.

@LP @LP

@Figure
@Location {TryAfterLine}
@Caption { Removing {@Sym epsilon}-transitions}
@Tag { removeeps }
{
@Diag {
@Tbl
aformat { @Cell A | @Cell B | @Cell C | @Cell D | @Cell i {ctr} E | @Cell iv{ctr} i{ctr} F }
marginhorizontal { 0.3c }
marginvertical { 0.2c }
{
@Rowa
A { A:: @Circle hsize {0.5f} {0.75f @Font {1}}}
C { B:: @Circle hsize {0.5f} {0.75f @Font {2}}}
E { C:: @Circle hsize {0.5f} {0.75f @Font {3}}}
F { ==> }
}
//
@Arrow from { A } to { B } ylabel { 1.2f @Font {@Sym epsilon "/"@M{T sub 1} }}
@Arrow from { B } to { C } ylabel { 1.2f @Font a"/"@M{T sub 2}} 
}
@Diag {
@Tbl
aformat { @Cell A | @Cell B | @Cell C | @Cell D | @Cell i {ctr} E | @Cell iv{ctr} i{ctr} F }
marginhorizontal { 0.3c }
marginvertical { 0.2c }
{
@Rowa
A { A:: @Circle hsize {0.5f} {0.75f @Font {1}}}
C { B:: @Circle hsize {0.5f} {0.75f @Font {2}}}
E { C:: @Circle hsize {0.5f} {0.75f @Font {3}}}
}
//
@CCurveArrow from { A } to { C } ylabel { 1.2f @Font {a "/" @M{T sub 1 {cup tsub {@tag}} T sub 2} }}
@Arrow from { B } to { C } ylabel { 1.2f @Font a"/"@M{T sub 2}} 
}
}
@DP

@ID @OneRow @Pas {
for arc in arcsfrom(state) do
    if arc.lbl = @Sym epsilon then
        if arc.@ttt.mark <> state then 
            for tmparc in arcsfrom(arc.@ttt) do
                addarc(state, tmparc.@ttt , tmparc.lbl , arc.tags @Sym union tsub {@tag} tmparc.tags)
            end
            arc.@ttt.mark = state
        end
        deletarc(arc)
    end
end
}


A survey on how to handle @Sym epsilon transitions is given in
@Cite {$vannoord00}. The idea of @I copying arcs is outlined in
@Cite {$ilieyu02}.

@End @SubSection

@SubSection
@Title { Resolving ambigous transitions }
@Begin
@PP
Propagating tags while removing ambigous transitions is the most complex
task of the entire process.

@Figure
@Location {TryAfterLine}
@Caption { Merging transitions}
@Tag { mergearcs }
{
@Diag {
@Tbl
aformat { @Cell A | @Cell B | @Cell C | @Cell D | @Cell  E | @Cell iv{ctr} i{ctr} F }
marginhorizontal { 0.3c }
marginvertical { 0.2c }
{
@Rowa
B {   }
@Rowa
E { B:: @Circle hsize {0.5f} {0.75f @Font {2}}}
@Rowa
A { A:: @Circle hsize {0.5f} {0.75f @Font {1}}}
F { ==> }
@Rowa
E { C:: @Circle hsize {0.5f} {0.75f @Font {3}}}
}
//
@CCurveArrow bias {0.5c} from { A } to { B } ylabel { 1.2f @Font A"/"@M{T sub 1}}
@CurveArrow  bias {0.5c} from { A } to { C } ylabel { 1.2f @Font B"/"@M{T sub 2}} ylabelprox {below}
}

@Diag {
@Tbl
aformat { @Cell  iv{ctr} A | @Cell width {2c} B | @Cell C | @Cell iv{ctr} D | @Cell  E | @Cell iv{ctr} i{ctr} F }
marginhorizontal { 0.3c }
marginvertical { 0.2c }
{
@Rowa
E { B:: @Circle hsize {0.5f} {0.75f @Font {2}}}
@Rowa
height{2.5c}
A { A:: @Circle hsize {0.5f} {0.75f @Font {1}}}
B {   }
D { D:: @Circle hsize {0.5f} {0.75f @Font {4}}}
@Rowa
E { C:: @Circle hsize {0.5f} {0.75f @Font {3}}}
}
//
@CCurveArrow  from { A } to { B } ylabel { 1.2f @Font {@M{A minus B} "/" @M{T sub 1}}}
@CurveArrow   from { A } to { C } ylabel { 1.2f @Font {@M{B minus A} "/" @M{T sub 2}}} ylabelprox {below}
@Arrow from { A } to { D } ylabel { 1.2f @Font {@M{A cap B " / " @M{T sub 1 cap T sub 2}} }} 
@CurveArrow   bias {0.2c} from { D@NE } to { B } zlabel { 1.2f @Font {{@Sym epsilon} "/" @M{( T sub 1 - T sub 2 ) sup {+}}}} zlabelprox {right}
@CCurveArrow  bias {0.2c} from { D@SE } to { C } zlabel { 1.2f @Font {{@Sym epsilon} "/" @M{( T sub 2 - T sub 2 ) sup {+}}}} zlabelprox {right}
}
}

@DP
Following the NFA construction rules of figure @NumberOf{re2nfa}, arcs
may be labeled with set of characters; if two arcs have
labels whose intersection is not empty, we have an ambigous transition.

Figure @NumberOf{mergearcs} shows the general case, table xx shows all the
possible cases.
# @M{A cap B notequal emptyset " " logicaland " "  A - B notequal emptyset
# " " logicaland " " B - A notequal emptyset}. 

@LP

@Figure
@Location {TryAfterLine}
@Caption { Merging transitions}
@Tag { mergearcs_a }
{
@Diag {
@Tbl
aformat { @Cell A | @Cell B | @Cell C | @Cell D |
          @Cell E | @Cell iv{ctr} i{ctr} F }
marginhorizontal { 0.3c }
marginvertical { 0.2c }
{
@Rowa
E { B:: @Circle hsize {0.5f} {0.75f @Font {2}}}
@Rowa
A { A:: @Circle hsize {0.5f} {0.75f @Font {1}}}
F { ==> }
@Rowa
E { C:: @Circle hsize {0.5f} {0.75f @Font {3}}}
}
//
@CCurveArrow bias {0.5c} from { A } to { B }
             ylabel { 1.2f @Font a" / "@M{@tag supp 0 on 1}}
@CurveArrow  bias {0.5c} from { A } to { C }
             ylabel { 1.2f @Font a" / "@M{@tag supp 0 on 2}}
             ylabelprox {below}
}

@Diag {
@Tbl
aformat { @Cell A | @Cell B | @Cell C | @Cell D |
          @Cell E | @Cell iv{ctr} i{ctr} F }
marginhorizontal { 0.3c }
marginvertical { 0.2c }
{
@Rowa
E { B:: @Circle hsize {0.5f} {0.75f @Font {2}}}
@Rowa
A { A:: @Circle hsize {0.5f} {0.75f @Font {1}}}
C { D:: @Circle hsize {0.5f} {0.75f @Font {4}}}
@Rowa
E { C:: @Circle hsize {0.5f} {0.75f @Font {3}}}
}
//
@CCurveArrow bias {0.5c} from {D } to { B } 
             ylabel { 1.2f @Font {@Sym epsilon "/"@M{@tag supp 1 on 1}}}
@CurveArrow  bias {0.5c} from { D } to { C } 
             ylabel { 1.2f @Font {@Sym epsilon "/"@M{@tag supp 1 on 2}}}
             ylabelprox {below}
@Arrow from {A} to {D} ylabel {1.2f @Font a}
}
}

@DP
The intuition behind figure @NumberOf{mergearcs_a} is that in state 1,
if we get @F {a}, we are not able to choose between going to state 2
or state 3 so we postpone the decision in state 4 (when we will have
access to another character).

@LP
The increment on tag will take into account the fact that we should
have applied the tag one position earlier.

@LP
Unfortunately an algorithm based on that simple intuition doesn't
always converge. There are times where ambiguities cannot be resolved
simply merging states and postponing decisions and we would enter
an endless loop, merging the same states over and over again.

@Figure
@Location {TryAfterLine}
@Caption { Merging transitions}
@Tag { mergearcs_b }
{
@Diag {
@Tbl
aformat { @Cell A | @Cell B | @Cell C | @Cell D | @Cell  E | @Cell iv{ctr} i{ctr} F }
marginhorizontal { 0.3c }
marginvertical { 0.2c }
{
@Rowa
B {   }
@Rowa
E { B:: @Circle hsize {0.5f} {0.75f @Font {2}}}
@Rowa
A { A:: @Circle hsize {0.5f} {0.75f @Font {1}}}
F { ==> }
@Rowa
E { C:: @Circle hsize {0.5f} {0.75f @Font {3}}}
}
//
@CCurveArrow bias {0.5c} from { A } to { B } ylabel { 1.2f @Font A"/"@M{T sub 1}}
@CurveArrow  bias {0.5c} from { A } to { C } ylabel { 1.2f @Font B"/"@M{T sub 2}} ylabelprox {below}
}

@Diag {
@Tbl
aformat { @Cell  iv{ctr} A | @Cell width {2c} B | @Cell C | @Cell iv{ctr} D | @Cell  E | @Cell iv{ctr} i{ctr} F }
marginhorizontal { 0.3c }
marginvertical { 0.2c }
{
@Rowa
E { B:: @Circle hsize {0.5f} {0.75f @Font {2}}}
@Rowa
height{2.5c}
A { A:: @Circle hsize {0.5f} {0.75f @Font {1}}}
B {   }
D { D:: @Circle hsize {0.5f} {0.75f @Font {4}}}
@Rowa
E { C:: @Circle hsize {0.5f} {0.75f @Font {3}}}
}
//
@CCurveArrow  from { A } to { B } ylabel { 1.2f @Font {@M{A minus B} "/" @M{T sub 1}}}
@CurveArrow   from { A } to { C } ylabel { 1.2f @Font {@M{B minus A} "/" @M{T sub 2}}} ylabelprox {below}
@Arrow from { A } to { D } ylabel { 1.2f @Font {@M{A cap B " / " @M{T sub 1 {cup tsub @tag " "} T sub 2}} }} 
# @CurveArrow   bias {0.2c} from { D@NE } to { B } zlabel { 1.2f @Font {{@Sym epsilon} "/" @M{( T sub 1 - T sub 2 ) sup {+}}}} zlabelprox {right}
# @CCurveArrow  bias {0.2c} from { D@SE } to { C } zlabel { 1.2f @Font {{@Sym epsilon} "/" @M{( T sub 2 - T sub 2 ) sup {+}}}} zlabelprox {right}
}
}


## @LP
## Let's now provide an example in figure @NumberOf{detaaa} of the determinization
## of  @I {(a*)(a)a}. During the example we'll skip the details on some trivial
## semplification to focus on the key aspects of the algorithm.
## 
## @LP
## The NFA created using the process outlined in figure @NumberOf{re2nfa}
## is shown in step @B {(1)}. Consider now the string "\"" @F {aaaa} "\"",
## the following table shows the trace of the NFA execution.
## @DP 
## 
## @Center 0.9 @Scale @Tbl
## i {ctr}
## marginvertical {0.1c}
## aformat { @Cell A | @Cell @F B | @Cell C | @Cell D | @Cell E | @Cell F | @Cell G | }
## {
## @Rowa A {@I state} B{@I char} C{@I pos} D{@M{bc sub 1}} E{@M{ec sub 1}} F{@M{bc sub 2}} G{@M{ec sub 2}}
## rulebelow{yes}
## @Rowa A {1}  B {a}  C{0} D{-} E{-} F{-} G{-}
## @Rowa A {2}  B {a}  C{0} D{0} E{-} F{-} G{-}
## @Rowa A {2}  B {a}  C{1} D{0} E{-} F{-} G{-}
## @Rowa A {2}  B {a}  C{2} D{0} E{-} F{-} G{-}
## @Rowa A {3}  B {a}  C{2} D{0} E{-} F{-} G{-}
## @Rowa A {4}  B {a}  C{2} D{0} E{2} F{-} G{-}
## }
## 
## 
## @Figure
## @Caption { Determinzation of @I {(a*)(a)a}}
## @Tag { detaaa }
## {
## @Diag {
## @Tbl
## i{ctr}
## width{expand}
## aformat { @Cell A | @Cell B | @Cell C | @Cell D | @Cell E | @Cell F | @Cell G | @Cell H | @Cell I  | @Cell J | @Cell i {right} iv {ctr} K }
## {
## @Rowa
## A { "  " A:: @Circle hsize {0.5f} {0.75f @Font {1}} "  "}
## B { "  " B:: @Circle hsize {0.5f} {0.75f @Font {2}} "  "}
## C { "  " C:: @Circle hsize {0.5f} {0.75f @Font {3}} "  "}
## D { "  " D:: @Circle hsize {0.5f} {0.75f @Font {4}} "  "}
## E { "  " E:: @Circle hsize {0.5f} {0.75f @Font {5}} "  "}
## F { "  " F:: @Circle hsize {0.5f} {0.75f @Font {6}} "  "}
## G { "  " G:: @Circle hsize {0.5f} {0.75f @Font {7}} "  "}
## H { "  " H:: @Circle hsize {0.5f} {0.75f @Font {8}} "  "}
## I { "  " I:: @Circle hsize {0.5f} {0.75f @Font {0}} "  "}
## K {(1)}
## 
## @Rowa E {  }
## @Rowa
## A { "  " AA:: @Circle hsize {0.5f} {0.75f @Font {1}} "  "}
## B { "  " AB:: @Circle hsize {0.5f} {0.75f @Font {2}} "  "}
## C { "  " AC:: @Circle hsize {0.5f} {0.75f @Font {3}} "  "}
## D { "  " AD:: @Circle hsize {0.5f} {0.75f @Font {4}} "  "}
## E { "  " AE:: @Circle hsize {0.5f} {0.75f @Font {5}} "  "}
## F { "  " AF:: @Circle hsize {0.5f} {0.75f @Font {6}} "  "}
## G { "  " AG:: @Circle hsize {0.5f} {0.75f @Font {7}} "  "}
## H { "  " AH:: @Circle hsize {0.5f} {0.75f @Font {8}} "  "}
## I { "  " AI:: @Circle hsize {0.5f} {0.75f @Font {0}} "  "}
## K {(2)}
## 
## @Rowa E {  } @Rowa E {  }
## @Rowa
## A { "  " BA:: @Circle hsize {0.5f} {0.75f @Font {1}} "  "}
## B { "  " BB:: @Circle hsize {0.5f}alabel {0.75f @Font {"{2;6}"}} alabelpos {S}  {0.75f @Font {9}} "  "}
## D { "  " BC:: @Circle hsize {0.5f} {0.75f @Font {2}} "  "}
## F { "  " BF:: @Circle hsize {0.5f} {0.75f @Font {6}} "  "}
## G { "  " BH:: @Circle hsize {0.5f} {0.75f @Font {8}} "  "}
## H { "  " BI:: @Circle hsize {0.5f} {0.75f @Font {0}} "  "}
## K {(3)}
## 
## @Rowa E {  } @Rowa E {  }
## @Rowa
## A { "  " CA:: @Circle hsize {0.5f} {0.75f @Font {1}} "  "}
## B { "  " CB:: @Circle hsize {0.5f} alabel {0.75f @Font {"{2;6}"}} alabelpos {S} {0.75f @Font {9}} "  "}
## D { "  " CC:: @Circle hsize {0.5f} {0.75f @Font {2}} "  "}
## F { "  " CF:: @Circle hsize {0.5f} {0.75f @Font {6}} "  "}
## G { "  " CH:: @Circle hsize {0.5f} {0.75f @Font {8}} "  "}
## H { "  " CI:: @Circle hsize {0.5f} {0.75f @Font {0}} "  "}
## K {(4)}
## 
## @Rowa E {  } @Rowa  E {  } @Rowa E {  }
## @Rowa
## A { "  " DA:: @Circle hsize {0.5f} {0.75f @Font {1}} "  "}
## B { "  " DB:: @Circle hsize {0.5f} alabel {0.75f @Font {"{2;6}"}} alabelpos {S} {0.75f @Font {9}} "  "}
## C { "  " DD:: @Circle hsize {0.5f} alabel {0.75f @Font {"{2;6;8}"}} alabelpos {S} {0.5f @Font {10}} "  "}
## E { "  " DC:: @Circle hsize {0.5f} {0.75f @Font {2}} "  "}
## G { "  " DF:: @Circle hsize {0.5f} {0.75f @Font {6}} "  "}
## H { "  " DH:: @Circle hsize {0.5f} {0.75f @Font {8}} "  "}
## I { "  " DI:: @Circle hsize {0.5f} {0.75f @Font {0}} "  "}
## K {(5)}
## 
## @Rowa E {  } @Rowa E {  } @Rowa E {  }
## @Rowa
## A { "  " EA:: @Circle hsize {0.5f} {0.75f @Font {1}} "  "}
## B { "  " EB:: @Circle hsize {0.5f} alabel {0.75f @Font {"{2;6}"}} alabelpos {S} {0.75f @Font {9}} "  "}
## C { "  " ED:: @Circle hsize {0.5f} alabel {0.75f @Font {"{2;6;8}"}} alabelpos {S} {0.5f @Font {10}} "  "}
## E { "  " EC:: @Circle hsize {0.5f} {0.75f @Font {2}} "  "}
## G { "  " EF:: @Circle hsize {0.5f} {0.75f @Font {6}} "  "}
## H { "  " EH:: @Circle hsize {0.5f} {0.75f @Font {8}} "  "}
## I { "  " EI:: @Circle hsize {0.5f} {0.75f @Font {0}} "  "}
## K {(6)}
## 
## @Rowa E {  } @Rowa E {  } @Rowa E {  } @Rowa E {  }
## @Rowa
## A { "  " FA:: @Circle hsize {0.5f} {0.75f @Font {1}} "  "}
## B { "  " FB:: @Circle hsize {0.5f} alabel {0.75f @Font {"{2;6}"}} alabelpos {S} {0.75f @Font {9}} "  "}
## C { "  " FD:: @Circle hsize {0.5f} alabel {0.75f @Font {"{2;6;8}"}} alabelpos {S} {0.5f @Font {10}} "  "}
## E { "  " FI:: @Circle hsize {0.5f} {0.75f @Font {0}} "  "}
## K {(7)}
##  @Rowa E {  }
## }
## //
## @Arrow from { A } to { B } ylabel { "  " {@Sym epsilon}"/"@M{( supp 0 on 1} }
## @CurveArrow from { B@NE } to { B@NW } ylabel { a } bias {0.7c}
## @Arrow from { B } to { C } ylabel { "  " {@Sym epsilon} }
## @Arrow from { C } to { D } ylabel { "  " {@Sym epsilon}"/"@M{ ) supp 0 on 1} }
## @Arrow from { D } to { E } ylabel { "  " {@Sym epsilon}"/"@M{ ( supp 0 on 2} }
## @Arrow from { E } to { F } ylabel { a }
## @Arrow from { F } to { G } ylabel { "  " {@Sym epsilon}"/"@M{ ) supp 0 on 2} }
## @Arrow from { G } to { H } ylabel { a }
## @Arrow from { H } to { I } ylabel { "  " {@Sym lambda}"/"$ "  " }
## 
## @Arrow from { AA } to { AB } ylabel { "  " {a}"/"@M{( supp 0 on 1} }
## @CurveArrow from { AB@NE } to { AB@NW } ylabel { a } bias {0.7c}
## @Arrow from { AB } to { AC } ylabel { "  " {@Sym epsilon} }
## @Arrow from { AC } to { AD } ylabel { "  " {@Sym epsilon}"/"@M{ ) supp 0 on 1} }
## @Arrow from { AD } to { AE } ylabel { "  " {@Sym epsilon}"/"@M{ ( supp 0 on 2} }
## @Arrow from { AE } to { AF } ylabel { a }
## @Arrow from { AF } to { AG } ylabel { "  " {@Sym epsilon}"/"@M{ ) supp 0 on 2} }
## @Arrow from { AG } to { AH } ylabel { a }
## @Arrow from { AH } to { AI } ylabel { "  " {@Sym lambda}"/"$ "  " }
## @CurveArrow from { AA } to { AF } ylabel { "  " {a}"/" @M{( supp 0 on 1} @M{) supp 0 on 1} @M{( supp 0 on 2} } ylabelprox{below}
## 
## @Arrow from { BA } to { BB } ylabel { "  " {a}"/"@M{( supp 0 on 1} }
## @Arrow from { BB } to { BC } ylabel { "  " {@Sym epsilon} }
## @CurveArrow from { BC@NE } to { BC@NW } ylabel { a } bias {0.7c}
## @Arrow from { BC } to { BF } ylabel { "  " {a}"/"@M{ ) supp 0 on 1 " " ( supp 0 on 2} }
## @Arrow from { BF } to { BH } ylabel { "  " {a}"/"@M{ ) supp 0 on 2} }
## @Arrow from { BH } to { BI } ylabel { "  " {@Sym lambda}"/"$ "  " }
## @CurveArrow from { BB } to { BF } ylabel { "  " {@Sym epsilon}"/" @M{) supp 1 on 1} @M{( supp 1 on 2} } ylabelprox{below}
## 
## @Arrow      from { CA } to { CB } ylabel { "  " {a}"/"@M{( supp 0 on 1} }
## @Arrow      from { CB } to { CC } ylabel { "  " {a} }
## @CurveArrow from { CC@NE } to { CC@NW } ylabel { a } bias {0.7c}
## @Arrow      from { CC } to { CF } ylabel { "  " {a}"/"@M{ ) supp 0 on 1 " " ( supp 0 on 2} }
## @Arrow      from { CF } to { CH } ylabel { "  " {a}"/"@M{ ) supp 0 on 2} }
## @Arrow      from { CH } to { CI } ylabel { "  " {@Sym lambda} "/"$ "  " }
## @CurveArrow from { CB } to { CF } ylabel { "  " {a}"/" @M{) supp 0 on 1} @M{( supp 0 on 2} } ylabelprox{above} bias {1.2c}
## @CurveArrow from { CB } to { CH } ylabel { "  " {a}"/" @M{) supp 1 on 1} @M{( supp 1 on 2} @M{) supp 0 on 2}} ylabelprox{above} bias {2.0c}
## 
## @Arrow      from { DA } to { DB } ylabel { "  " {a}"/"@M{( supp 0 on 1} }
## @Arrow      from { DB } to { DD } ylabel { "  " {a} }
## @Arrow      from { DD } to { DC } ylabel { "  " {@Sym epsilon} }
## @CurveArrow from { DC@NE } to { DC@NW } ylabel { a } bias {0.7c}
## @Arrow      from { DC } to { DF } ylabel { "  " {a}"/"@M{ ) supp 0 on 1 " " ( supp 0 on 2} }
## @Arrow      from { DF } to { DH } ylabel { "  " {a}"/"@M{ ) supp 0 on 2} }
## @Arrow      from { DH } to { DI } ylabel { "  " {@Sym lambda} "/"$ "  " }
## @CurveArrow from { DD } to { DF } ylabel { "  " {@Sym epsilon}"/" @M{) supp 1 on 1} @M{( supp 1 on 2} } ylabelprox{above} bias {1.2c}
## @CurveArrow from { DD } to { DH } ylabel { "  " {@Sym epsilon}"/" @M{) supp 2 on 1} @M{( supp 2 on 2} @M{) supp 1 on 2}} ylabelprox{above} bias {2.0c}
## 
## @Arrow      from { EA } to { EB } ylabel { "  " {a}"/"@M{( supp 0 on 1} }
## @Arrow      from { EB } to { ED } ylabel { "  " {a} }
## @Arrow      from { ED } to { EC } ylabel { "  " {a} }
## @CurveArrow from { EC@NE } to { EC@NW } ylabel { a } bias {0.7c}
## @Arrow      from { EC } to { EF } ylabel { "  " {a}"/"@M{ ) supp 0 on 1 " " ( supp 0 on 2} }
## @Arrow      from { EF } to { EH } ylabel { "  " {a}"/"@M{ ) supp 0 on 2} }
## @Arrow      from { EH } to { EI } ylabel { "  " {@Sym lambda} "/"$ "  " }
## @CurveArrow from { ED } to { EF } ylabel { "  " {a}"/" @M{) supp 0 on 1} @M{( supp 0 on 2} } ylabelprox{above} bias {1.2c}
## @CurveArrow from { ED } to { EH } ylabel { "  " {a}"/" @M{) supp 1 on 1} @M{( supp 1 on 2} @M{) supp 0 on 2} } ylabelprox{above} bias {2.0c}
## @CurveArrow from { ED } to { EI } ylabel { "  " {@Sym lambda}"/"$ @M{) supp 2 on 1} @M{( supp 2 on 2} @M{) supp 1 on 2}} ylabelprox{above} bias {2.8c}
## 
## @Arrow      from { FA } to { FB } ylabel { "  " {a}"/"@M{( supp 0 on 1} }
## @Arrow      from { FB } to { FD } ylabel { "  " {a} }
## @CurveArrow from { FD@NE } to { FD@NW } ylabel { a } bias {0.7c}
## @Arrow from { FD } to { FI } ylabel { "  " {@Sym lambda}"/"$ @M{) supp 2 on 1} @M{( supp 2 on 2} @M{) supp 1 on 2}} ylabelprox{above} bias {2.8c}
## 
## }
## }

@DP

@End @SubSection

@EndSubSections

@End @Section


#### REFERENCE #####################################

{ @Reference
@Tag { AhoUllman77 }
@Type { Book }
@Author { Alfred V. Aho and Jeffrey D. Ullman }
@Title { Principles of Compiler Design  }
@Publisher { Addison-Wesley Longman Publishing Co., Inc }
@Edition { ed. I }
@Year { 1977 }
}

{ @Reference
@Tag {Laurikari}
@Type {MastersThesis}
@Author {Ville Laurikari}
@Institution {Helsinki University of Technology}
@Publisher {}
@Title {Efficient submatch addressing for regular expressions}
@URL {http://citeseer.ist.psu.edu/480392.html}
@Year {2001}
}

{ @Reference
@Tag {dube00}
@Type {Article}
@Author {Danny Dube and Marc Feeley}
@Journal {Acta Informatica}
@Number {2}
@Title {Efficiently building a parse tree from a regular expression}
@URL {http://citeseer.ist.psu.edu/340667.html}
@Volume {37}
@Year {2000}
}

{ @Reference
@Tag {ilieyu02}
@Type {InProceedings}
@Author {Lucian Ilie and Sheng Yu}
@Journal {}
@Pages {279-288}
@Publisher {Springer-Verlag}
@Title {Constructing NFA s by Optimal Use of Positions in Regular Expressions}
@URL {http://www.springerlink.com/content/emvg6jgyyfxm1apv/}
@Volume {2373}
@Year {2002}
@InTitle {CPM '02: Proceedings of the 13th Annual Symposium on Combinatorial Pattern Matching}
}

{ @Reference
@Tag {vannoord00}
@Type {InBook}
@Author {Gertjan Van Noord}
@Title {Treatment of @Sym epsilon -- Moves in Subset Construction}
@URL {http://citeseer.ist.psu.edu/vannoord98treatment.html}
@Volume {26}
@Year {2000}
@InTitle {Computational Linguistics, {MIT} Press for the Association for Computational Linguistics}
}

